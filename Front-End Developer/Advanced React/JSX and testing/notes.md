- JSX is a syntax extension to JavaScript, used by React to describe how the UI should look
  - Looks like HTML but is an abstraction combining markup and business logic into a "component"
    - The UI in React is structured into a tree of components
    - React produces pure HTML, CSS, and JavaScript from its JSX components
  - An "element" in React is a JavaScript object that describes the hierarchy of HTML output as a plaint object
    - Similar to the component tree hierarchy, but each node represents a plain object describing a component instance or DOM node and its desired properties
    - The main attributes are `type` for the HTML element type and `props` for the passed properties (attributes) (including `children`)
      - The `type` can also be a function corresponding to a React component rather than an HTML element type such as `<button>`
        - React identifies the components in the JSX tree and converts them to DOM elements, and this allows the mixing of components and HTML elements, resulting in the virtual DOM (JavaScript representation of the real DOM)
    - When re-rendering the UI, React's "diffing" operation compares the new JSX tree to the previous JSX tree, calculates the difference between the versions, and then applies the minimum changes necessary for implementing the update
- React's composition model provides two key features: "containment" and "specialization"
  - "Containment" refers to components that are generic because they do not know what `children` will be contained within them
  - "Specialization" refers to components that are special cases of othe components, such as a button component that is a special case of a generic button component
- There are serveral types that can be passed to the `children` prop of a JSX expression
  - String literals can be passed but JSX will remove: leading and trailing whitespaces, lines adjacent to tags, and newlines inside the string
  - JSX elements such as `<div>` can be passed
  - React fragments (`<React.Fragment>` or `<>`) can wrap children
    - This is useful when returning multiple JSX elements without adding extra nodes to the DOM
  - JavaScript expressions can be passed by wrapping in curly brackets (`<div>{''}</div>`)
  - Functions can be passed, in which case they will function like any other prop
  - Booleans, Null and Undefined can be passed but will be ignored
- React can be imported in a .js file as a whole global object with `import React from 'react'` or individual functions as a named import with `import { functionName } from 'react'`
- The `children` prop in a React component can be dynamically transformed
  - The `React.cloneElement(element, [props])` top-level API clones a React element into a copy, where `element` is the element and `[props]` is any new props that will be merged into existing props on the element
    - Useful for modifying children properties, adding to children properties, or extending functionality of children components
  - The `React.Children` top-level API provides utilities for dealing with transformation of the children prop structure (such as `.map()`)
- As `props` is an object, an object can be declared instead of declaring `props` as the argument for a functional component (`const ComponentName = ({ children }) => {}`)
- The "spread operator" (`...`) can copy an object (such as `props`) by spreading the properties with `...objectName`
  - This can be leveraged to copy and then update properties when instantiating a new object with `{ ...objectName, propertyName: value }`
  - React provides a pattern for using the spread operator for declaration of element attributes, such that `<ElementName attributeName={value}>` can be `<ElementName {...objectName}>` where the object has the same properties as would be declared as attributes
    - Additional attributes can be declared as normal, which enables specification through componentization
    - The order of the attributes declaration determines whether the spread operator overrides other attributes
- "Cross-cutting concerns" is generic functionality that is not related to application business logic, such as handling permission roles, handling errors, and logging
  - "Higher order component" (HOC) is an advanced pattern for a function that takes a component as input, extends the component with enhanced functionality, then returns a new component
    - This is useful as an alternative to custom hooks as that requires any component that uses the custom hook to be transformed from stateless to stateful
    - Uses a special syntax for passing a component and the functions the hooks utilize when extending component functionality
      - An example would be `const withAddedFunctionality = ComponentName => { return (props) => { return <ComponentName /> } }`
      - Component passed to HOC should never be mutated inside the HOC
      - Props should be passed through from input to output component (using spread operator) with minimal changes
    - A functional programming pattern called "currying" (used in React Redux) is used for maximizing function composition
      - An example is the HOC declared as `connect(selector, actions)(ComponentName)` which is equal to `const HOC = connect(selector, actions); HOC(ComponentName)`
      - "Single-argument" HOCs convert an input component to an enhanced output component, which makes them easy to compose together such as in `compose(withAddedFunctionality, withEnhancement, connect(selector))`, which can then be used with an input component to enhance its functionality
    - HOC should not be declared in the scope of a component, as the enhanced component will differ between re-renders which forces React to remount and erase previous state
    - React `refs` are not handled by props so they will not be passed through a HOC, but there exists a `React.forwardRef` API for handling this case
    - It is recommended that HOCs are named starting with `with` and using camelcase, as this expresses the enhancing nature of HOCs
    - A functional component enhanced with an additional prop through a HOC can access that property through its props object declaration, similar to how `children` is accessed in a functional component
  - "Render props" is a technique where a `render` prop of type function is passed to a functional component (`<ComponentName render={data => (<p>Information: {data.information}</p>)} />`) and then called with data from inside the component in the return of the component
    - An example is a component that fetches data based on an input `url`, passes the data with a `return render(data)` call, and then the data is handled in the `render={data => ()}` attribute of the component instance to dynamically render a JSX element
- "Automation tests" help with discovering bugs/defects, ensuring sofware quality, and saving resources, before deployment to production
  - Best practices for writing tests are to avoid including implementation details by working with actual DOM nodes rather than instances of React components, tests should resemble software usage, and tests should be maintainable in the long run
  - "React Testing" library is a set of utilities for testing React components without relying on implementation details, and this library fulfils all the test best practices
    - Imported with `import { render } from "@testing-library/react"` where `render` is a function for rendering the component to be tested and asserted against
      - Library also exports a `screen` object which is a reference to the `document.body` body and has every query pre-bound to the whole document when performing a search
  - "Jest" (JavaScript test runner) provides an artificial DOM called "jsdom", good iteration speed, and powerful features such as "mocking"
    - "Mocking" is an imitation that allows complex code to be replaced with similar but simpler code
      - A "mock function" is created in Jest with `const functionName = jest.fn()` and used to track how a function is called by external code
    - Test file for a component can be named as `ComponentName.test.js`
    - Jest automatically injects global functions such as `test` and `expect` into any files
    - The `describe` function wraps one or more `test` calls to describe the context
    - The `test` function takes two arguments: a description of the test and a function
      - In this function the `render` method is called on a React component followed by an assertion with the `expect` function
      - The React Testing `screen` utility object and `fireEvent` method can be used in a `test` to simulate interaction with the UI and test for expected changes
        - An error is thrown if there is no element found with one of the querying methods on the `screen` object, such as `screen.getByRole()` and `screen.getByLabelText()`
          - The `screen.getByLabelText()` selects a `<label>` element but returns the corresponding `<input>` element
        - `fireEvent.change(input, { target: { value: value } })` can be used on an input element found with a method on `screen` (such as `screen.getByLabelText()`) to update its value
        - `fireEvent.click(screen.getByRole("button"))` would identify elements by their `role="button"` attribute and perform a click event
        - `expect(functionName).not.toHaveBeenCalled()` tests for the expectation that the aforementioned mock function was not called by external code during a test of the UI
- "Continuous Integration" (CI) is a software development technique where developers iteratively and often push changes to a shared version control system, rather than pushing changes at the end of the development cycle
  - Each version control merge triggers an automated set of scripts to automatically build and test the application
  - The CI pipeline builds the updated code on the server, runs automated tests, alerts the developer in case of errors and then the developer fixes the errors
    - The next stage is deployment of a new software version to the staging server, where the internal Quality Assurance (QA) team can verify changes in a production-like environment
- "Style guides" contain rules about how to write code, such as whether to use single or double quotes, levels of indentation, maximum line length etc.